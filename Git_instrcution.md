![Git logo](1_u2wteZPmRZPQh9xFaw-hvA.jpeg)

# Working with Git

## 1. Проверка наличия установленного Git

В терминале выполнить команду `git version`

Если Git установлен, появится сообщение с информацией о версии программы

Иначе выдаст сообщение об ошибке

## 2. Установка Git

Загружаем последнюю версию Git с официального cайта https://git-scm.com/downdloads

## 3. Настройка Git

При первом использовании Git необходимо представиться. Для этого понадобится ввести в терминале 2 команды: 
```
git config --global user.name «Ваше имя англ буквами»
git config --global user.email ваша_почта@example.com
```
## 4. Инициализация репозитория

Чтобы созадть локальный репозиторий, необходимо ввести команду `git init`. Таким образом создается системная папка с нашим проектом. Далее создаём файл с расширением **.md**. Git может работать не только с файлами **.md**, но и с любыми другими форматами, markdown в этом плане имеет больше возможностей. После этого необходимо дать git команду о фиксировании этого файла в репозитории. Для начала проверяем статус нашего файла посредством выполнения команды `git status`. Статус **No commits yet** - изменения пока что не зафиксированы, **Untracked files** - git пока что его не отслеживает, сам файл будет выделен красным шрифтом. 

## 5. Добавление файлу версионности в локальном репозитории

Для того, чтобы git начал отслеживание нашего файла, вводим команду `git add "название нашего файла"`. Снова вводим команду `git status`, файл будет выделен зелёным, что будет означать, что git его отслеживает. Чтобы отменить отслеживание файла, нужно ввести команду `git rm --cached "название нашего файла"`.
Также, если нам не нужен какой то файл в нашем локальном репозитории, мы можем его удалить. Для этого необходимо ввести команду `git rm название файла`. Если файл не будет отслеживаем, *git* его спокойно удалит. Если же он будет отслеживаться, т.к. мы уже дали ему до этого версионность, *git* предложит удалить его принудительно, для чего нам нужно будет ввести команду `git rm -f название файла`.

## 6. Фиксирование изменений и сообщение о новой версии файла

Чтобы зафиксировать изменения в файле, используется команда `git commit -m "Название версии"`. Перед этим необходимо сохранить текущую версию файла посредством команды **ctrl + s**. Если команда `git status` дает недостаточно подробный результат, например если нам необходимо не только получить список отредактированных
файлов, но и узнать, что именно изменилось, необходимо воспользоваться командой `git diff`. Она показывает добавленные и удаленные строки — то есть все вставки в программу. Команда `git diff` без дополнительных параметров позволяет посмотреть, что было изменено, но пока не проиндексировано. Важно помнить, что сама по себе команда `git diff` показывает не все изменения,
сделанные с момента последней фиксации состояния, а только те, которые еще не проиндексированы. То есть если вы проиндексировали все сделанные изменения, команда `git diff` ничего нам не вернет.

## 7. Вывод истории сохранений

Чтобы вывести историю всех имеющихся сохранений, вводится команда `git log`. Здесь содержится информация о всех версиях файла (коммитах), т.е. число, время изменения, авторство и уникальный идентификационный номер каждой из веток.

## 8. Перемещение между сохранениями

Чтобы вернуться к предыдущей версии нашего файла, вводим уже указанную выше команду `git log`. Выбираем нужную версию, копируем ее идентификационный номер, после чего вводим команду `git checkout "номер нашего сохранения"`. Для того, чтобы вернуться обратно к фактической версии повторно вводим команду `git checkout` и добавляем в конце команды `master`. 

## 9. Игнорирование файлов

Если у нас имеются файлы, которые мы не хотим ни автоматически добавлять в репозиторий, ни видеть в списке неотслеживаемых, то в подобных случаях создается файл `.gitignore`.
Настройки файла .gitignore защищает от случайного добавления в репозиторий файлов, которые там не нужны. К примеру, мы хотим добавить в наш *git* изображение. Для начала поместим само изображение в рабочую папку репозитория. Далее вводим команду `git status`. *Git* выдаст сообщение о том, что файл с изображением не отслеживается. Добавляем нашему изображению версионность посредством ввода команды `git add "наименование нашего изображения"`. Чтобы изображение было отображаемо в нашем файле, вводим команду `![Git logo](наименование изображения)`. После чего создаем файл `.gitignore` и даём ему "руководство" игнорировать все файлы соответствующего формата. В нашем случае это *.jpeg*. Обязательно перед указанием формата файла нужно поставить знак *.   По такому же принципу можно добавлять в данный файл и остальные форматы, если мы хотим, чтобы *git* их не отслеживал и не фиксировал в нашем репозитории. После данных манипуляций добавляем версионность также файлу `.gitignore` посредством ввода команды `git add .gitignore` и создаём коммит, чтобы зафиксировать изменения. 
 
## 10. Создание веток, перемещение между ними, слияние и удаление

Чтобы создать новую ветку, вводим команду `git branch название_ветки`. Чтобы просмотреть спиcок имеющихся веток, достаточно ввести ту же команду только без наименования ветки, т.е. `git branch`. Перемещение между ветками - команда `git checkout название_ветки`. Также мы можем одновременно и создать новую ветку, и сразу переместиться на неё, введя команду `git checkout -b название_ветки`. Стоит обратить внимание, что называть ветку можно любым именем, но если мы хотим ввести двойное название, к примеру состоящее из двух слов, мы не должны для этого использовать пробелы, иначе *git* будет выдавать ошибку, т.е. слова пишем слитно, либо ставим между ними знак нижнего подчеркивания (_).Мы можем работать в нужной нам ветке, а также вносить все изменения в неё посредством всех команд, описанных выше. Как только нас устроит нынешнее состояние рабочей ветки, мы можем спокойно выполнить её слияние с основной веткой *master*, предварительно перейдя на неё. Слияние веток происходит посредством выполнения команды `git merge название_ветки`. К примеру если мы вернёмся обратно на ветку *master*, далее введем команду `git merge название_ветки`, у нас сразу же добавится информация из той ветки, которая будет указана в названии, в нашу рабочую основную ветку *master*. Создание веток очень полезно, так как позволяет редактировать нам несколько черновиков и работать с ними по отдельности и уже потом вносить все изменения в "чистовик". Если конечно же мы уверены в отсутствии ошибок в этих черновиках. Чтобы удалить уже слитую ветку, вводим команду `git branch -d название ветки`. Также, если в сливаемую ветку не будут внесены изменения, git выдаст сообщение об этом и предложит удалить ветку принудительно, что можно сделать с помощью команды `git branch -D <название ветки>`. Можно просмотреть все сохранения во всех имеющихся ветках посредством просмотра т.н. "древа сохранений". Для этого вводится команда `git log --graph`. Таким образом можно увидеть визуализацию связей между ветками. 

## 11. Конфликты при слиянии веток и их разрешение

При выполнении команды `git merge` могут возникать конфликты. Это происходит в том случае, когда в разных ветках одна и та же строка написана по-разному, хотя и информация может не иметь отличий вовсе или иметь, но не существенные. 
При возникновении конфликта нам будет дано 3 варианта на выбор: оставить данные ветки *master*, принять данные из другой ветки с удалением данных в ветке *master* соответственно и в последнем случае принять данные из обеих веток. Обязательно после разрешения конфликта необходимо выполнить манипуляции по закоммичиванию наших действий посредством ввода команды `git commit -am <наименование_коммита"`.

## 12. Работа с Markdown

__Выделение текста__

Для выделения текста курсивом необходимо обрамить его звёздочками (*) или знаком нижнего подчеркивания (_): *Пример* либо _Пример_

Чтобы выделить текст полужирным, необходимо обрамить его двойными звездочками (**) или двойными знаками нижнего подчеркивания (__): **Пример** либо __Пример__

Альтернативные способы выделения текста жирным или курсивом нужны для адекватного чередования этих способов и удобства. Например, _текст может быть одновременно и в курсиве, и в **полужирном**_.  

__Списки__

Добавление ненумерованных списков - выделение пунктов звездочками (*) или знаком +:
* Пример1
* Пример2
* Пример3
+ Пример 4
+ Пример 5

Нумерованные списки - просто пронумеровать наши элементы:
1. Пример1
2. Пример2
3. Пример3


__Заголовки__

Выделение заголовков - символ "#". Количество символов задаёт уровень заголовка. Всего поддерживается 6 уровней. Пример:
# Один
## Два
### Три
#### Четыре
##### Пять
###### Шесть

Также заголовки можно выделять символами = или - (не менее 3-х символов подряд), если это заголовки первого (=) или второго (-) уровней. Пример:

===Текст===

---Текст--- 

Чтобы текст был зачёркнут, необходимо обрамить его в двойную тильду (~~). Пример:
~~Text~~

## 13. Работа с удаленными репозиториями

1. В первую очередь создаём аккаунт на GitHub
2. Создаём локальный репозиторий
3. Связываем удалённый репозиторий с локальным 

Чтобы просмотреть какие удалённые серверы у нас уже настроены, следует выполнить команду `git remote`. Она перечисляет список имён-сокращений для всех уже указанных удалённых дескрипторов. Если репозиторий уже склонирован, должен отобразиться по крайней мере *origin* — это имя по умолчанию, которое Git присваивает серверу.
Чтобы добавить новый удалённый Git-репозиторий под именем-сокращением, к которому будет проще обращаться, необходимо выполнить команду `git remote add <ссылка на репозиторий>`.

Если у нас имеется ветка, настроенная на отслеживание удалённой ветки, мы можем использовать команду `git pull`. Она автоматичеси извлекает и затем сливает данные из удалённой ветки в вашу текущую ветку. Это позволяет получать изменения и сразу обновлять рабочую копию так, чтобы она соответствовала удаленному репозиторию.   Команда `git pull` используется для извлечения и загрузки содержимого из удаленного репозитория и немедленного обновления локального репозитория этим содержимым. Команда `git pull` на самом деле представляет собой комбинацию двух других команд: `git fetch` и `git merge`. На первом этапе `git pull` выполняется команда `git fetch`, ограниченная локальной веткой, на которую указывает HEAD. Сразу после загрузки содержимого команда `git pull` выполняет слияние. Для слитого содержимого создается новый коммит, а указатель HEAD обновляется и начинает указывать на этот новый коммит. Сначала команда `git pull` запускает команду `git fetch` для загрузки содержимого из указанного удаленного репозитория. Затем выполняется команда `git merge`, объединяющая ссылки и указатели удаленного содержимого в новый локальный коммит слияния. Команда `git pull` — одна из множества команд, отвечающих за синхронизацию удаленного содержимого. Команда `git remote`используется, чтобы указать, на каких удаленных конечных точках будут работать команды синхронизации. Команда `git push` используется для выгрузки содержимого в удаленный репозиторий.
Когда ваш проект достигает момента, когда вы хотите поделиться наработками, вам необходимо отправить (push) их в главный репозиторий. Команда для этого действия простая: `git push [удал. сервер] [ветка]`. Чтобы отправить вашу ветку master на сервер origin (повторимся, что клонирование как правило настраивает оба этих имени автоматически), вы можете выполнить следующую команду для отправки наработок обратно на сервер: `git push origin master` 
Операция клонирования создаёт на вашем компьютере точную копию удаленного репозитория.

Необходимость клонировать существующий удаленный репозиторий возникает в ситуациях, когда вы решаете поработать над уже существующим кодом. Для выполнения этой операции в Git предусмотрена команда `git clone`.
Ссылку на удаленный репозиторий можно получить тем же способом, что мы разбирали выше. Нужно нажать на зеленую кнопку Code на главной странице репозитория на GitHub.

## 14. Команда pull-request

Одной из самых важных частей GitHub является создание форков. Форк (от англ. fork – вилка) – точная копия репозитория, но в вашем аккаунте. Форки нужны, чтобы вносить свои изменения в проект, к репозиторию которого у вас нет прямого доступа. pull-request – функция GitHub, позволяющая попросить владельца репозитория, от которого мы сделали форк, загрузить наши изменения обратно в свой репозиторий.
1. Для начала зайдем на страницу репозитория проекта. Нажимаем на кнопку Fork. После этого Git создаст точную копию этого репозитория в вашем аккаунте.
2. Клонируем репозиторий к себе на компьютер командой git clone.
3. Сделаем коммит и выполним git push, чтобы загрузить наши изменения в удаленный репозиторий.
4. GitHub подскажет нам, что наша ветка опережает ветку исходного репозитория на один коммит и предлагает сделать пулл-реквест.
5.	Нажимаем на кнопку Compare на подсказке GitHub, либо переходим на вкладку Pull Requests и нажимаем New pull request.
6.	Перед нами откроется страница создания пулл-реквеста. Здесь мы можем просмотреть внесенные изменения и выбрать две ветки: одну в исходном репозитории, на нее будут залиты наши изменения, вторую – в нашем репозитории, с нее будут скачаны изменения. Как только мы выбрали ветки и убедились, что не внесли никаких лишних изменений, нажимаем кнопку *Create pull request*.
7.	Теперь мы попадаем на страницу описания наших изменений. Здесь необходимо описать, что за изменения вы внесли и почему они были необходимы. Сообщение, которое оставили мы, видно на картинке. Оно отражает суть и необходимость внесенных изменений. Как только мы закончили с описанием, можно нажимать кнопку *Create pull request*.
8.	Теперь мы попадаем на страницу уже созданного пулл-реквеста в изначальном репозитоии. В нашем случае он выглядит так. Именно так будет выглядеть наш пулл-реквест и для владельца репозитория. На этой странице он сможет писать комментарии, указывая на ошибки или задавая вопросы. После того, как владелец репозитория просмотрит наши изменения и убедится, что они не имеют вредоносный характер, он сможет принять наш пулл-реквест. Тогда все изменения, добавленные в этот пулл-реквест нами, будут залиты в исходный репозиторий.

